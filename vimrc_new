" VIM configuration
" ------------------------------------------------------------
"
" Key Shortcut List
"
" <f1> help
" <f2> buffer explorer
" <f3> tagbar
" <f4> spelling check
" <f5> taglist window horizentally
" <f6> toggle line wrap
" <f7> nerdtree
" <f8> gundo
" <f9> screen send region
" <f10> toggle limit vertical line
" <f12> toggle paste
"
" :W write and remove trailing white spaces
" <esc><esc> remove search highlight and re-arrange syntax color
" <S-tab> <tab> for expanding snips
" \<tab> indent the line or region
" <C-c>. <C-c>, move the line a tab
" \- draw a separate line
" \w save
" \s save with trailing white spaces
" <C-c><C-e> ConqueTerm send line or region
" \l open taglist window horizentally
" \lr open taglist window vertically
" <C-c>c let syntastic do syntax check
" <C-c>C un-highlight the error message of syntastic
" <C-c><C-n> screen executes a line and go to the next
" <C-c><C-c> screen execute a paragraph and go to the next
" <C-c>% start screen and split window vertically
" <C-c>" start screen and split window horizentally
" <C-c>q quit screen splitted window; save and quit
" <C-c>= tabularize according to '='
" <C-c>x search commands
" <C-c>f search for functions in current buffer
" <C-c>F narrow the function list down with a word under cursor
" \o toggle window zoom
"
" ------------------------------------------------------------

"  General
set nocompatible
syntax enable
filetype on
filetype plugin on
filetype indent on

set ruler
set ai sw=4
set mouse=a
set ttymouse=sgr

set backspace=indent,eol,start

set cindent
set smartindent
set autoindent
set tabstop=8 softtabstop=4 shiftwidth=4 expandtab smarttab

autocmd filetype go setlocal tabstop=8 shiftwidth=8 noexpandtab

set wildmenu " a really cool feature
set pastetoggle=<F12> "pt: useful so auto-indenting doesn't mess up code when pasting
set virtualedit=block "ve: let cursor move past the last char in <C-V> mode
set nostartofline "sol: avoid moving cursor to BOL when jumping around
set cryptmethod=blowfish "cm: use (much) stronger blowfish encryption
set ignorecase "ic: ignores case when pattern matching
set smartcase "scs: ignores ignorecase when pattern contains uppercase characters

set grepprg=grep\ -nH\ $*

set foldmethod=indent
set foldlevel=99

set incsearch
set ignorecase
set smartcase
set hlsearch
nmap <silent> <leader>q :nohlsearch<CR>
imap <silent> <leader>q <C-o>:nohlsearch<cr>

set laststatus=2   " Always show the statusline
set encoding=utf-8 " Necessary to show Unicode glyphs

" ------------------------------------------------------------
" Auto-trailing white spaces
fun! <SID>StripTrailingWhitespaces()
    " Save the current search and cursor position
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Strip the whitespace
    "silent! execute ':' . a:line1 . ',' . a:line2 . 's/\s\+$//e'
    %s/\s\+$//e
    " Restore the saved search and cursor position
    let @/=_s
    call cursor(l, c)
endfun

fun! <SID>W_func()
    call <SID>StripTrailingWhitespaces()
    w
endfun

fun! <SID>WQ_func()
    call <SID>W_func()
    q
endfun

fun! <SID>WA_func()
    call <SID>StripTrailingWhitespaces()
    wa
endfun

fun! <SID>WQA_func()
    call <SID>WA_func()
    q
endfun

inoremap <CR> <CR>.<BS>

command -nargs=0 W call <SID>W_func()
command -nargs=0 WQ call <SID>WQ_func()
command -nargs=0 WA call <SID>WA_func()
command -nargs=0 WQA call <SID>WQA_func()
command Wq WQ
command Wa WA
command Wqa WQA
command WQa WQA
command WqA WQA
command Q q
command QA qa
command Qa qa
"autocmd BufWritePre * :call <SID>StripTrailingWhitespaces()
"autocmd BufWritePre * :%s/\s\+$//e

" ------------------------------------------------------------
" try to preserve the cursor column position
set nostartofline

set clipboard+=unnamedplus,unnamed,autoselect

" auto insert a new line after {
inoremap {<cr> {<cr>}<c-o><s-o>

" Make double-<Esc> clear search highlights
nnoremap <silent> <Esc><Esc> <Esc>:nohlsearch<CR>:syntax sync fromstart<cr><Esc>

map <F6> :set wrap!<cr>

" Manually indent
nmap <leader><tab> ==
imap <leader><tab> <C-o>==
vmap <leader><tab> =

" indent/un-indent
imap <C-c>. <C-t>
imap <C-c>, <C-d>
nmap <C-c>. a<C-t><ESC>
nmap <C-c>, a<C-d><ESC>

" paste in Insert-mode
"imap <C-p> <ESC>pa

"autocmd BufEnter * let &titlestring = '' . expand("%:t")
"set title

imap <leader>- <space><C-o>60i-<esc>a

nmap <leader>w :w<cr>
imap <leader>w <C-o>:w<cr>
nmap <leader>s :W<cr>
imap <leader>s .<C-o>:call <SID>StripTrailingWhitespaces()<cr><bs><C-o>:w<cr>

"set wildignore+=*/tmp/*,*.so,*.swp,*.zip     " MacOSX/Linux

" Improve scrolling speed for long lines
"" set ttyfast " u got a fast terminal
"" set ttyscroll=3
set lazyredraw " to avoid scrolling problems

" ------------------------------------------------------------
"  Pathogen
execute pathogen#infect()

" ------------------------------------------------------------
"  C++ class public, protected and private indent
set cinoptions+=g2,h2

" ------------------------------------------------------------
"  Auto-complete

" Disable completion warning messages
try
  set shortmess+=c
catch /E539: Illegal character/
endtry

set ofu=syntaxcomplete#Complete
" . for current buffer, b for all loaded buffers,
" u for all un-loaded buffers, ] for tag files,
" w for open windows
set dictionary+=/usr/share/dict/words
set complete=.,b,u,],w,k

" let g:jedi#popup_select_first = 0
" let g:jedi#auto_vim_configuration = 0
" au FileType python setlocal completeopt-=preview
"let g:loaded_jedi = 1
" YouCompleteMe ----------------------
"let g:loaded_youcompleteme = 1 " disabled
"let g:ycm_auto_trigger = 1
let g:ycm_complete_in_comments = 2
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_path_to_python_interpreter = '/usr/bin/python'
let g:ycm_key_list_select_completion = ['<Down>']
let g:ycm_key_list_previous_completion = ['<Up>']
"let g:ycm_key_invoke_completion = '<C-Space>'
let g:ycm_min_num_of_chars_for_completion = 2
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
"let g:ycm_filetype_specific_completion_to_disable = {'cpp': 1, 'c': 0}
let g:ycm_global_ycm_extra_conf = '/home/hqian/.vim/bundle/.ycm_extra_conf.py'

" Ultisnips options -------------------

let g:UltiSnipsExpandTrigger="<S-tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<S-tab>"
"imap <C-@> <S-tab>

" neocomplete ----------------------------------
let g:loaded_neocomplete = 1 " disabled
"" let g:acp_enableAtStartup = 0
"" let g:neocomplete#enable_at_startup = 1
"" let g:neocomplete#enable_smart_case = 1
"" let g:neocomplete#sources#syntax#min_keyword_length = 3
"" let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
"" let g:neocomplete#auto_completion_start_length = 2
"" let g:neocomplete#enable_fuzzy_completion = 1
""
"" " " "
"" " " "
"" " " " inoremap <expr><Down> pumvisible() ? "\<C-n>" : "\<Down>"
"" " " " inoremap <expr><Up> pumvisible() ? "\<C-p>" : "\<Up>"
"" " "
"" let g:neocomplete#disable_auto_complete = 1
"" let g:neocomplete#enable_auto_select = 0
""
"" let g:neocomplete#enable_insert_char_pre = 1
""
"" let g:neocomplete#enable_prefetch = 1
""
"" let g:marching_enable_neocomplete = 1
""
"" if !exists('g:neocomplete#force_omni_input_patterns')
""     let g:neocomplete#force_omni_input_patterns = {}
"" endif
""
"" let g:neocomplete#force_omni_input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
""
"" let g:neocomplcache_force_overwrite_completefunc = 1
"" if !exists('g:neocomplcache_omni_functions')
""     let g:neocomplcache_omni_functions = {}
"" endif
"" if !exists('g:neocomplcache_force_omni_patterns')
""     let g:neocomplcache_force_omni_patterns = {}
"" endif
"" let g:neocomplcache_force_overwrite_completefunc = 1
"" " " let g:neocomplcache_force_omni_patterns['python'] = '[^. t].w*'
"" " " set ofu=syntaxcomplete#Complete
"" let g:jedi#auto_initialization = 1
"" au FileType python let b:did_ftplugin = 1
"" let g:jedi#show_all_signatures= 0
"" "let g:jedi#popup_on_dot = 0
"" " set pumheight=10

" Supertab ------------------------------
let loaded_supertab = 1
"" let g:SuperTabDefaultCompletionType = "context"
"" "let g:SuperTabDefaultCompletionType = "<C-x><C-u>"
"" let g:SuperTabContextDefaultCompletionType = "<c-x><c-o>"
"" let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
"" let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
"" let g:SuperTabContextDiscoverDiscovery =
""             \ ["&omnifunc:<c-x><c-o>", "&completefunc:<c-x><c-u>"]
"" let g:SuperTabMappingForward = '<S-tab>'
"" let g:SuperTabMappingBackward = '<leader><space>'
"" let g:SuperTabMappingTabLiteral = '<Tab>'
"" let g:SuperTabLongestEnhanced = 1
""
"" "imap <f5> <S-tab>
"" "imap <C-c><space> <S-tab>
"" "imap <C-@> <S-tab>
""
"" " autocmd FileType *
"" "             \ if &omnifunc != '' |
"" "             \ call SuperTabChain(&omnifunc, "<c-p>") |
"" "             \ call SuperTabSetDefaultCompletionType("<c-x><c-u>") |
"" "             \ endif
""
"" " au FileType python set omnifunc=pythoncomplete#Complete

"" inoremap <expr><Down> pumvisible() ? "\<C-n>" : "\<Down>"
"" inoremap <expr><Up> pumvisible() ? "\<C-p>" : "\<Up>"

"" set conceallevel=2
"" set concealcursor=vin
"" let g:clang_snippets=1
"" let g:clang_conceal_snippets=1
"" " The single one that works with clang_complete
"" let g:clang_snippets_engine='clang_complete'

" Limit popup menu height
set pumheight=10

"set completeopt-=longest,menuone,preview completeopt+=longest,menuone,preview

"" autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
"" autocmd InsertLeave * if pumvisible() == 0|pclose|endif

" ------------------------------------------------------------
"  Conque-Shell
" can use C-w to switch window in Insert-mode
let g:ConqueTerm_CWInsert = 1
" continue to update the display when not focused
let g:ConqueTerm_ReadUnfocused = 1
let g:ConqueTerm_TERM = 'xterm'
" close the buffer when the app exits
let g:ConqueTerm_CloseOnEnd = 1
" enter Insert-mode when focused
let g:ConqueTerm_InsertOnEnter = 1
let g:ConqueTerm_StartMessages = 0

nmap <silent> <C-e><C-e> <S-v><f9><CR><C-w><C-p>:call Goto_next_nonblank()<CR>
imap <silent> <C-e><C-e> <ESC><S-v><f9><CR><C-w><C-p>:call Goto_next_nonblank()<CR>a
vmap <silent> <C-e><C-e> <f9><CR><C-w><C-p>:'><CR>:call Goto_next_nonblank()<CR>

" ------------------------------------------------------------
"  Tex

"" " atp
"" let g:tex_flavor='latex'
"" let g:Tex_CompileRule_dvi = 'latex -src-specials -interaction=nonstopmode $*'
"" let g:atp_folding =1
"" let g:atp_tab_map=1
"" let g:tex_conceal = ''

" ------------------------------------------------------------
"  tagList
let Tlist_Ctags_Cmd = '/usr/bin/ctags'
"let Tlist_Use_Right_Window = 1
"let Tlist_Use_Horiz_Window = 1
let Tlist_Use_SingleClick = 1
let Tlist_Show_One_File = 1
let Tlist_Close_On_Select = 1
"let Tlist_Display_Tag_Scope = 0
nmap \l :let Tlist_Use_Right_Window = 0<CR>:let Tlist_Use_Horiz_Window = 1<CR>:TlistToggle<CR>
nmap <f5> :let Tlist_Use_Right_Window = 0<CR>:let Tlist_Use_Horiz_Window = 1<CR>:TlistToggle<CR>
nmap \lr :let Tlist_Use_Horiz_Window = 0<CR>:let Tlist_Use_Right_Window = 1<CR>:TlistToggle<CR>

" ------------------------------------------------------------
"  Python support
let g:pyflakes_use_quickfix = 0
let g:pep8_map='<leader>8'
let python_highlight_all = 1

" ------------------------------------------------------------
"  Line number
" set number
hi LineNr ctermfg=243 ctermbg=253
set nonumber

" ------------------------------------------------------------
"  File types
au BufNewFile,BufRead *.sql_in setlocal ft=sql
au BufNewFile,BufRead *.py_in setlocal ft=python
au BufNewFile,BufRead *.notes setlocal ft=notes

au BufNewFile,BufRead *.erl imap -- <space>-><space>
au BufNewFile,BufRead *.ex imap -- <space>-><space>
au BufNewFile,BufRead *.exs imap -- <space>-><space>
au BufNewFile,BufRead *.erl imap __ <space><-<space>
au BufNewFile,BufRead *.ex imap __ <space><-<space>
au BufNewFile,BufRead *exs imap __ <space><-<space>

" ------------------------------------------------------------
"  nerdtree
nmap <F7> :NERDTreeTabsToggle<CR>
let g:nerdtree_tabs_open_on_gui_startup = 0
let NERDTreeMouseMode = 2

" ------------------------------------------------------------
"  vim-airline
let g:loaded_airline = 1 " disabled

let g:airline_theme="solarized"
let g:airline_exclude_preview = 1
let g:ctrlspace_use_tabline = 1

let g:airline_enable_branch     = 1
let g:airline_enable_syntastic  = 1

" vim-powerline symbols
let g:airline_left_sep          = ''
let g:airline_left_alt_sep      = ''
let g:airline_right_sep         = ''
let g:airline_right_alt_sep     = ''
let g:airline_branch_prefix     = ''
let g:airline_readonly_symbol   = ''
let g:airline_linecolumn_prefix = ''

" ------------------------------------------------------------
"  vim-move
let g:move_key_modifier = 'C'

" ------------------------------------------------------------
"  Open file at last edit position
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

" ------------------------------------------------------------
"  Auto line breaks for text and latex files
au BufEnter *.txt setl ts=4 sw=4 tw=70 "fo=aw2q
au BufEnter *.tex setl ts=4 sw=4 tw=70 "fo=aw2tq
au FileType ruby setl sw=2 sts=2 et
au FileType notes setl ts=4 sw=4 tw=70 "fo=aw2tq

" ------------------------------------------------------------
"  rainbow
let g:rainbow_active = 1
let g:rainbow_conf = {
\   'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
\   'ctermfgs': ['darkred', 'brown', 'darkblue', 'darkgray', 'darkgreen', 'darkcyan', 'red', 'darkmagenta', 'darkcyan'],
\   'operators': '_,_',
\   'parentheses': [['(',')'], ['\[','\]'], ['{','}']],
\   'separately': {
\       '*': {},
\       'lisp': {
\           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
\           'ctermfgs': ['darkgray', 'darkblue', 'darkmagenta', 'darkcyan', 'darkred', 'darkgreen'],
\       },
\       'html': {
\           'parentheses': [['(',')'], ['\[','\]'], ['{','}'], ['<\a[^>]*[^/]>\|<\a>','</[^>]*>']],
\       },
\       'tex': {
\           'operators': '',
\           'parentheses': [['(',')'], ['\[','\]']],
\       },
\   }
\}

" ------------------------------------------------------------
"  gundo.vim
nnoremap <F8> :GundoToggle<CR>
set undodir=~/.vim-undo
set undofile
set undolevels=100 "maximum number of changes that can be undone
set undoreload=1000 "maximum number lines to save for undo on a buffer reload
"let g:gundo_disable = 1

" ------------------------------------------------------------
"  Spell-checking
map <F4> :setlocal spell! spelllang=en_us<CR>

" ------------------------------------------------------------
"  Highlight long lines
" augroup vimrc_autocmds
"     autocmd BufEnter * highlight Overlength ctermbg=234 ctermfg=None
"     "call matchadd('ColorColumn1', '\%65v', 100)
"     autocmd BufEnter * match OverLength /\%65v/
" augroup END

function! g:ToggleColorColumn()
    if &colorcolumn != ''
        setlocal colorcolumn&
    else
        setlocal colorcolumn=71
    endif
endfunction

nnoremap <silent> <f10> :call g:ToggleColorColumn()<CR>
imap <silent> <f10> <C-o>:call g:ToggleColorColumn()<cr>

" ------------------------------------------------------------
"  Color scheme
set background=dark

let g:solarized_termcolors= 256
let g:solarized_termtrans = 1
let g:solarized_bold = 1
let g:solarized_underline = 1
let g:solarized_italic = 1
let g:solarized_contrast = "high"
let g:solarized_visibility= "high"
colorscheme solarized
highlight Comment cterm=italic ctermfg=023
highlight scalaMultilineComment cterm=italic ctermfg=023
highlight scalaTrailingComment cterm=italic ctermfg=023
" visual mode background
hi Visual cterm=None ctermbg=236 ctermfg=None
hi StatusLine ctermbg=233 ctermfg=24
set statusline=%F%m%r%h%w%=(%{&ff}/%y)\ (line\ %l\/%L,\ col\ %c)\ %{fugitive#statusline()}

" display a warning if &paste is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*

" ------------------------------------------------------------
"  Auto-read file if changed externally
"  reload when executing any command, but not automatically
" set autoread
" au CursorHold * checktime

" set autoread
" " reload when entering the buffer or gaining focus
" au FocusGained,BufEnter * :silent! redraw!
" " save when exiting the buffer or losing focus
" au FocusLost,WinLeave * :silent! w

" ------------------------------------------------------------
"  Not really useful

" nnoremap Q <nop>
" set showbreak=↪

" ------------------------------------------------------------
"  bufexplorer
noremap <silent> <F2> :BufExplorer<CR>
imap <silent> <F2> <ESC>:w<cr>:BufExplorer<CR>

" ------------------------------------------------------------
"  indentLine
let g:indentLine_color_term = 235

" ------------------------------------------------------------
"  Vim-R-plugin
autocmd FileType r setlocal formatoptions=cq
let vimrplugin_applescript = 0

" ------------------------------------------------------------
"  syntastic
let g:syntastic_python_checkers=['pylint']
let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'
let g:syntastic_enable_balloons = 1
let g:syntastic_mode_map = { 'mode': 'passive' }

nmap <C-c>c :w<CR>:SyntasticCheck<CR>
imap <C-c>c <ESC>:w<CR>:SyntasticCheck<CR>a
nmap <C-c>C :SyntasticReset<CR>
imap <C-c>C <ESC>:SyntasticReset<CR>a

" ------------------------------------------------------------
"  tagbar

" use this to speed up cursor movement
autocmd FileType tagbar setlocal nocursorline nocursorcolumn

nmap <silent> <F3> :TagbarToggle<CR>
let g:tagbar_singleclick = 1
let g:tagbar_sort = 0

let g:tagbar_type_scala = {
    \ 'ctagstype' : 'Scala',
    \ 'kinds'     : [
        \ 'p:packages',
        \ 'V:values',
        \ 'v:variables',
        \ 'T:types',
        \ 't:traits',
        \ 'o:objects',
        \ 'O:case objects',
        \ 'a:aclasses',
        \ 'c:classes',
        \ 'C:case classes',
        \ 'm:methods'
    \ ]
\ }

let g:tagbar_type_r = {
    \ 'ctagstype' : 'r',
    \ 'kinds'     : [
        \ 'f:Functions',
        \ 'g:GlobalVariables',
        \ 'v:FunctionVariables',
        \ 'm:Methods',
        \ 'G:Generics',
        \ 'c:Classes'
    \ ]
\ }

let g:tagbar_type_markdown = {
    \ 'ctagstype' : 'markdown',
    \ 'kinds' : [
        \ 'h:Heading_L1',
        \ 'i:Heading_L2',
        \ 'k:Heading_L3'
    \ ]
\ }

let g:tagbar_type_puppet = {
    \ 'ctagstype': 'puppet',
    \ 'kinds': [
        \'c:class',
        \'s:site',
        \'n:node',
        \'d:definition'
      \]
\}

let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }

let g:tagbar_type_sql = {
            \ 'ctagstype' : 'pgsql',
            \ 'kinds' : [
            \ 'f:Functions',
            \ 'a:Aggregates',
            \ 't:Types'
            \]
            \ }

" ------------------------------------------------------------
"  Scala
" let g:scala_sort_across_groups=1
" au BufEnter *.scala setl formatprg=java\ -jar\ $HOME/.vim/scalariform.jar\ -f\ -q\ +alignParameters\ +alignSingleLineCaseStatements\ +doubleIndentClassDeclaration\ +preserveDanglingCloseParenthesis\ +rewriteArrowSymbols\ +preserveSpaceBeforeArguments\ --stdin\ --stdout
"nmap <leader>m :SortScalaImports<CR>gggqG<C-o><C-o><leader><w>

set fillchars+=stl:\ ,stlnc:\

au BufNewFile,BufRead *.sbt setlocal ft=sbt

" ------------------------------------------------------------
"  screen
let g:ScreenImpl = "Tmux"
let g:ScreenShellTmuxInitArgs = '-2'
let g:ScreenShellAttachTargetCurrent = 1

function! Goto_next_nonblank()
    let cur = line(".")
    let end = line("$")
    for i in range(cur+1, end+1)
        if (len(getline(i)) > 0)
            call cursor(i, 1)
            return
        endif
    endfor
    call cursor(cur, len(getline(cur)))
    return
endfunction

nmap <silent> <C-c><C-n> <S-v>:ScreenSend<CR>:call Goto_next_nonblank()<CR>
imap <silent> <C-c><C-n> <ESC><S-v>:ScreenSend<CR>:call Goto_next_nonblank()<CR>a
vmap <silent> <C-c><C-n> :ScreenSend<CR>:'><CR>:call Goto_next_nonblank()<CR>

nmap <silent> <C-c><C-c> vip<C-c><C-n>
imap <silent> <C-c><C-c> <ESC>vip<C-c><C-n>a
vmap <silent> <C-c><C-c> <C-c><C-n>

" generate random number at end of current line
function! Random()
    python from random import randint
    python from vim import command
    python command("return %d" % randint(0,1000))
endfun

function! Start_screenShell_v()
    if $TMUX == ''
        echoerr '****** You need to start tmux first! ******'
        return
    endif
    let r = Random()
    let title = 'Scrn' . r
    ScreenShell!
    call system("tmux rename-window " . title)
endfunction

function! Start_screenShell_s()
    if $TMUX == ''
        echoerr '****** You need to start tmux first! ******'
        return
    endif
    let r = Random()
    let title = 'Scrn' . r
    ScreenShell
    call system("tmux rename-window " . title)
endfunction

function! Start_screenIPython_v()
    if $TMUX == ''
        echoerr '****** You need to start tmux first! ******'
        return
    endif
    let r = Random()
    let title = 'Scrn' . r
    IPython!
    call system("tmux rename-window " . title)
endfunction

function! Start_screenIPython_s()
    if $TMUX == ''
        echoerr '****** You need to start tmux first! ******'
        return
    endif
    let r = Random()
    let title = 'Scrn' . r
    IPython
    call system("tmux rename-window " . title)
endfunction

nmap <silent> <C-c>% :call Start_screenShell_v()<CR>
imap <silent> <C-c>% <C-o>:call Start_screenShell_v()<CR>
nmap <silent> <C-c>" :call Start_screenShell_s()<CR>
imap <silent> <C-c>" <C-o>:call Start_screenShell_s()<CR>

function! s:ScreenShellListener()
    if g:ScreenShellActive
        nmap <silent> <C-c>q :ScreenQuit<CR>
        imap <silent> <C-c>q <ESC>:ScreenQuit<CR>
    else
        nmap <silent> <C-c>q :wq<CR>
        imap <silent> <C-c>q <ESC>:wq<CR>
    endif
endfunction

function! s:ScreenShortcutForPython()
    nmap <buffer> <C-c>% :call Start_screenIPython_v()<CR>
    imap <buffer> <C-c>% <C-o>:call Start_screenIPython_v()<CR>
    nmap <buffer> <C-c>" :call Start_screenIPython_s()<CR>
    imap <buffer> <C-c>" <C-o>:call Start_screenIPython_s()<CR>
endfunction

autocmd FileType python call <SID>ScreenShortcutForPython()

augroup ScreenShellEnter
    autocmd User * call <SID>ScreenShellListener()
augroup END
augroup ScreenShellExit
    autocmd User * call <SID>ScreenShellListener()
augroup END

" ------------------------------------------------------------
"  Use Alt-<arrow> to jump around
imap f <C-o>w
imap B <C-o>b
nmap f w
nmap B b

" ------------------------------------------------------------
"  tabular
vmap <C-c>= :Tabularize /=<CR>

" ------------------------------------------------------------
"  ctrlp
nmap <C-c>x :CtrlPCmdPalette<CR>
imap <C-c>x <C-o>:CtrlPCmdPalette<CR>

let g:ctrlp_extensions = ['funky']
let g:ctrlp_funky_syntax_highlight = 1
nnoremap <C-c>f :CtrlPFunky<Cr>

" narrow the list down with a word under cursor
nnoremap <C-c>F :execute 'CtrlPFunky ' . expand('<cword>')<Cr>

let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)$',
  \ 'file': '\v\.(exe|so|dll)$',
  \ 'link': 'some_bad_symbolic_links',
  \ }

let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . --cached --exclude-standard']

" ------------------------------------------------------------
"  dbext
" let g:dbext_default_profile_PG = 'type=PGSQL:passwd=:host=localhost:user=qianh1:dbname=madlib'

" ------------------------------------------------------------
" erlang
let erlang_show_errors = 0

" ------------------------------------------------------------
"  fzf
"set rtp+=~/.fzf
"nmap <leader>z :FZF<cr>

" ------------------------------------------------------------
"  limelight
let g:limelight_conceal_ctermfg = 240

" ------------------------------------------------------------
"  unknown
command -nargs=* -complete=help H vertical belowright help <args>

" ------------------------------------------------------------
"  ag.vim
"let g:aghighlight=1

" ------------------------------------------------------------
" Zoom / Restore window.
function! s:ZoomToggle() abort
    if exists('t:zoomed') && t:zoomed
        execute t:zoom_winrestcmd
        let t:zoomed = 0
    else
        let t:zoom_winrestcmd = winrestcmd()
        resize
        vertical resize
        let t:zoomed = 1
    endif
endfunction
command! ZoomToggle call s:ZoomToggle()
nnoremap <silent> <leader>o :ZoomToggle<CR>

" ------------------------------------------------------------
"  vim-pandoc
au VimEnter *.md hi Conceal ctermbg=None ctermfg=DarkMagenta

" ------------------------------------------------------------
"  Scheme indentation
autocmd FileType lisp,scheme imap <cr> <cr>.<C-o>==<C-o>^<C-o>x

